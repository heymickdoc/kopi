using Kopi.Core.Models.SQLServer;

namespace Kopi.Core.Utilities;

public static class DataTypeHelper
{
    private const StringComparison SC = StringComparison.OrdinalIgnoreCase;

    /// <summary>
    ///  Determines if the given SQL data type is string-based, e.g. VARCHAR, CHAR, TEXT, etc.
    /// </summary>
    /// <param name="sqlDataType"></param>
    /// <returns></returns>
    internal static bool IsStringType(string sqlDataType)
    {
        var stringBasedTypes = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "CHAR",
            "NCHAR",
            "VARCHAR",
            "NVARCHAR",
            "TEXT",
            "NTEXT"
        };

        return stringBasedTypes.Contains(sqlDataType);
    }

    /// <summary>
    ///  Determines if the given SQL data type is integer based, e.g. INT, BIGINT, etc.
    /// </summary>
    /// <param name="sqlDataType"></param>
    /// <returns></returns>
    internal static bool IsIntegerType(string sqlDataType)
    {
        var integerTypes = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "INT",
            "BIGINT",
            "SMALLINT",
            "TINYINT"
        };

        return integerTypes.Contains(sqlDataType);
    }

    /// <summary>
    /// Determines if the given SQL data type is decimal based, e.g. DECIMAL, FLOAT, etc.
    /// </summary>
    /// <param name="sqlDataType"></param>
    /// <returns></returns>
    internal static bool IsDecimalType(string sqlDataType)
    {
        var decimalTypes = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "DECIMAL",
            "NUMERIC",
            "FLOAT",
            "REAL",
            "MONEY",
            "SMALLMONEY"
        };

        return decimalTypes.Contains(sqlDataType);
    }

    public static bool IsDateType(string sqlDataType)
    {
        var dateTypes = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "DATE",
            "DATETIME",
            "DATETIME2",
            "SMALLDATETIME",
            "DATETIMEOFFSET"
        };

        return dateTypes.Contains(sqlDataType);
    }

    public static bool IsMoneyType(string sqlDataType)
    {
        var moneyTypes = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "MONEY",
            "SMALLMONEY"
        };

        return moneyTypes.Contains(sqlDataType);
    }

    /// <summary>
    ///  Determines if the given SQL data type is binary based, e.g. BINARY, VARBINARY, IMAGE, etc.
    /// </summary>
    /// <param name="sqlDataType">The data type</param>
    /// <returns>True if it is</returns>
    public static bool IsBinaryType(string sqlDataType)
    {
        var binaryTypes = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "BINARY",
            "VARBINARY",
            "IMAGE"
        };

        return binaryTypes.Contains(sqlDataType);
    }

    /// <summary>
    /// Estimates the "cardinality" (number of possible unique values) for a column
    /// based on its data type. Used to cap row generation.
    /// </summary>
    public static long GetTheoreticalMaxCardinality(ColumnModel column, int maxLength)
    {
        // This is a rough estimation.
        // We only care about data types with low cardinality.
        switch (column.DataType.ToLower())
        {
            case "bit":
                return 2;

            case "tinyint":
                return 256;

            case "smallint":
                return 65536;

            case "char":
            case "varchar":
            case "nchar":
            case "nvarchar":
                if (maxLength == 1)
                {
                    // 95 printable ASCII chars. A safe, low bet for 'varchar(1)'.
                    // (Assuming nchar/nvarchar(1) won't have 65k+ unique chars generated by Bogus)
                    return 95;
                }

                if (maxLength == 2)
                {
                    return 95 * 95; // ~9k
                }

                // If max length is > 2, or unknown (-1), assume it's "infinite" for our purposes.
                return long.MaxValue;

            // All other types (int, bigint, guid, datetime, etc.)
            // have cardinality far higher than any configMaxRowCount.
            default:
                return long.MaxValue;
        }
    }

    /// <summary>
    ///  Gets the maximum length for string-based SQL data types.
    /// Takes into account, things like NVARCHAR using 2 bytes per character.
    /// It also limits MAX to reasonable defaults for community edition.
    /// </summary>
    /// <param name="column">The column data</param>
    /// <returns></returns>
    public static int GetMaxLength(ColumnModel column)
    {
        /*
         * Here's how I think this should work:
         * 1. If the data type is CHAR, VARCHAR, or TEXT:
         *    - If MaxLength is specified and not zero, return that value.
         *    - If MaxLength is not specified or zero, return 8000 (limit for TEXT in Community edition).
         * 2. If the data type is NCHAR, NVARCHAR, or NTEXT:
         *    - If MaxLength is specified and not zero, return MaxLength
         *    - If MaxLength is not specified or zero, return 4000 (limit for NVARCHAR in Community edition).
         * 3. For other string types:
         *    - If MaxLength is specified, return that value.
         *    - If MaxLength is not specified, return 255 as a default.
         */

        if (column.DataType.Equals("char", SC) ||
            column.DataType.Equals("varchar", SC) ||
            column.DataType.Equals("text", SC))
        {
            if (int.TryParse(column.MaxLength, out var maxLengthInt) && maxLengthInt != 0)
            {
                return maxLengthInt;
            }

            return 8000; // Limiting to 8000 characters for TEXT in the Community edition
        }
        
        if (column.DataType.Equals("nvarchar", SC) ||
            column.DataType.Equals("nchar", SC) ||
            column.DataType.Equals("ntext", SC))
        {
            if (int.TryParse(column.MaxLength, out var maxLengthInt) && maxLengthInt != 0)
            {
                return maxLengthInt; // NVARCHAR uses 2 bytes per character
            }

            return 4000; // NVARCHAR max length in characters
        }
        
        if (!string.IsNullOrEmpty(column.MaxLength)) return int.TryParse(column.MaxLength, out var len) ? len : 255;
        
        return 255; // Default max length
    }

    public static (long, long) GetMinMaxIntegerValues(string sqlDataType)
    {
        return sqlDataType.ToLower() switch
        {
            "tinyint" => (0, 255),
            "smallint" => (-32_768, 32_767),
            "int" => (-2_147_483_648, 2_147_483_647),
            "bigint" => (-9_223_372_036_854_775_808, 9_223_372_036_854_775_807),
            _ => throw new ArgumentException($"Data type '{sqlDataType}' is not an integer type.")
        };
    }
}