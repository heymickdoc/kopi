using System.Text;
using Kopi.Core.Models.Common;
using Kopi.Core.Utilities;

namespace Kopi.Core.Services.PostgreSQL.Target;

public class PostgresScriptCreationService
{
    /// <summary>
    /// Generates the SQL to create the database itself.
    /// </summary>
    public static string GenerateDatabaseScript(KopiConfig config)
    {
        // Note: This needs to be executed while connected to the 'postgres' maintenance database.
        var dbName = DatabaseHelper.GetDatabaseName(config.SourceConnectionString, DatabaseType.PostgreSQL);
        return $"CREATE DATABASE \"{dbName}\" WITH ENCODING = 'UTF8';";
    }

    /// <summary>
    /// Generates scripts to create all schemas found in the source model.
    /// </summary>
    public static List<string> GenerateSchemaScripts(SourceDbModel sourceDb)
    {
        var scripts = new List<string>();

        // Gather all distinct schemas from tables, views, procs, etc.
        var allSchemas = sourceDb.Tables.Select(t => t.SchemaName)
            .Union(sourceDb.Views.Select(v => v.SchemaName))
            .Union(sourceDb.StoredProcedures.Select(p => p.SchemaName))
            .Union(sourceDb.Functions.Select(f => f.SchemaName))
            .Union(sourceDb.UserDefinedDataTypes.Select(u => u.SchemaName))
            .Distinct()
            .Where(s => s != "public" && s != "information_schema" &&
                        s != "pg_catalog") // 'public' usually exists, but 'if not exists' handles it safely anyway
            .ToList();

        foreach (var schema in allSchemas)
        {
            scripts.Add($"CREATE SCHEMA IF NOT EXISTS \"{schema}\";");
        }

        return scripts;
    }

    public static List<string> GenerateUserDefinedDataTypeScripts(SourceDbModel sourceDb)
    {
        // UDTs (Domains/Enums) should be created before tables.
        // The CreateScript was already generated by the Source service (Postgres syntax).
        return sourceDb.UserDefinedDataTypes
            .Select(u => u.CreateScript)
            .ToList();
    }

    public static List<string> GenerateTableScripts(SourceDbModel sourceDb)
    {
        var scripts = new List<string>();

        foreach (var table in sourceDb.Tables)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"CREATE TABLE \"{table.SchemaName}\".\"{table.TableName}\" (");

            var columnDefinitions = new List<string>();

            foreach (var col in table.Columns)
            {
                var def = $"    \"{col.ColumnName}\" {col.DataType}";

                // Handle Lengths
                // Updated to use DataTypeHelper
                if (DataTypeHelper.IsStringType(col.DataType) &&
                    !string.IsNullOrEmpty(col.MaxLength) &&
                    col.MaxLength != "MAX" &&
                    int.TryParse(col.MaxLength, out _))
                {
                    def += $"({col.MaxLength})";
                }

                // Handle Precision/Scale
                // We purposefully don't use DataTypeHelper.IsDecimalType here because types like 
                // MONEY or FLOAT/REAL in Postgres do not accept (Precision, Scale) syntax in DDL.
                if (col.DataType.Equals("numeric", StringComparison.OrdinalIgnoreCase) ||
                    col.DataType.Equals("decimal", StringComparison.OrdinalIgnoreCase))
                {
                    if (col.NumericPrecision > 0)
                        def += $"({col.NumericPrecision},{col.NumericScale})";
                }

                def += col.IsNullable ? " NULL" : " NOT NULL";

                // --- FIX FOR SEQUENCE ERROR ---
                // Check if this is a legacy SERIAL column (defined by a nextval default)
                bool isSerial = !string.IsNullOrWhiteSpace(col.DefaultDefinition) &&
                                col.DefaultDefinition.Trim().StartsWith("nextval", StringComparison.OrdinalIgnoreCase);

                // Identity (Modern) OR Serial (Legacy converted to Modern)
                // We convert explicit nextval() calls to IDENTITY columns to ensure the sequence 
                // is automatically created in the target DB.
                if (col.IsIdentity || isSerial)
                {
                    def += " GENERATED BY DEFAULT AS IDENTITY";
                }

                // Defaults (Only add if we didn't just turn it into an Identity column)
                if (!string.IsNullOrEmpty(col.DefaultDefinition) && !col.IsIdentity && !isSerial)
                {
                    def += $" DEFAULT {col.DefaultDefinition}";
                }

                columnDefinitions.Add(def);
            }

            sb.AppendLine(string.Join(",\n", columnDefinitions));

            // Primary Key
            var pk = sourceDb.PrimaryKeys.FirstOrDefault(p =>
                p.SchemaName == table.SchemaName && p.TableName == table.TableName);
            if (pk != null)
            {
                sb.AppendLine(",");
                var quotedCols = pk.PrimaryKeyColumns.Select(c => $"\"{c}\"");
                sb.Append($"    CONSTRAINT \"{pk.PrimaryKeyName}\" PRIMARY KEY ({string.Join(", ", quotedCols)})");
            }

            sb.AppendLine("\n);");
            scripts.Add(sb.ToString());
        }

        return scripts;
    }

    public static List<string> GenerateIndexScripts(SourceDbModel sourceDb)
    {
        var scripts = new List<string>();

        foreach (var idx in sourceDb.Indexes.Where(i => !i.IsPrimaryKey)) // PKs handled in table creation
        {
            var columns = string.Join(", ",
                idx.IndexColumns.OrderBy(c => c.KeyOrdinal).Select(c => $"\"{c.ColumnName}\""));
            var unique = idx.IsUnique ? "UNIQUE " : "";

            var sql =
                $"CREATE {unique}INDEX \"{idx.IndexName}\" ON \"{idx.SchemaName}\".\"{idx.TableName}\" ({columns});";
            scripts.Add(sql);
        }

        return scripts;
    }

    public static List<string> GenerateForeignKeyScripts(SourceDbModel sourceDb)
    {
        var scripts = new List<string>();

        foreach (var rel in sourceDb.Relationships)
        {
            var childCols = string.Join(", ",
                rel.ForeignKeyColumns.OrderBy(c => c.KeyOrdinal).Select(c => $"\"{c.ParentColumnName}\""));
            var parentCols = string.Join(", ",
                rel.ForeignKeyColumns.OrderBy(c => c.KeyOrdinal).Select(c => $"\"{c.ReferencedColumnName}\""));

            var sql = $@"
                ALTER TABLE ""{rel.ParentSchema}"".""{rel.ParentTable}"" 
                ADD CONSTRAINT ""{rel.ForeignKeyName}"" 
                FOREIGN KEY ({childCols}) 
                REFERENCES ""{rel.ReferencedSchema}"".""{rel.ReferencedTable}"" ({parentCols});";

            scripts.Add(sql);
        }

        return scripts;
    }

    public static List<string> GenerateStoredProcedureScripts(SourceDbModel sourceDb)
    {
        // Postgres pg_get_functiondef returns the full CREATE OR REPLACE definition
        return sourceDb.StoredProcedures
            .Select(sp => sp.Definition.EndsWith(";") ? sp.Definition : sp.Definition + ";")
            .ToList();
    }

    public static List<string> GenerateFunctionScripts(SourceDbModel sourceDb)
    {
        // Postgres pg_get_functiondef returns the full CREATE OR REPLACE definition
        return sourceDb.Functions
            .Select(fn => fn.Definition.EndsWith(";") ? fn.Definition : fn.Definition + ";")
            .ToList();
    }

    public static List<string> GenerateViewScripts(SourceDbModel sourceDb)
    {
        return sourceDb.Views
            .Select(v => v.CreateScript.EndsWith(";") ? v.CreateScript : v.CreateScript + ";")
            .ToList();
    }

    public static List<string> GenerateExtensionScripts(SourceDbModel sourceDb)
    {
        var scripts = new List<string>();

        foreach (var ext in sourceDb.Extensions)
        {
            // We use IF NOT EXISTS to be safe (idempotent).
            // We also specify the schema if it was captured, to ensure it lands in the same place (e.g. public vs utils).
            var schemaClause = string.IsNullOrWhiteSpace(ext.SchemaName) ? "" : $" WITH SCHEMA \"{ext.SchemaName}\"";

            // "CREATE EXTENSION IF NOT EXISTS "citext" WITH SCHEMA "public";"
            scripts.Add($"CREATE EXTENSION IF NOT EXISTS \"{ext.Name}\"{schemaClause};");
        }

        return scripts;
    }
}