using Dapper;
using Kopi.Core.Interfaces;
using Kopi.Core.Models.Common;
using Kopi.Core.Services.Common;
using Kopi.Core.Services.Docker;
using Kopi.Core.Utilities;
using Npgsql;

namespace Kopi.Core.Services.PostgreSQL.Target;

public class PostgresTargetDbOrchestratorService(
    KopiConfig config,
    SourceDbModel sourceDbData,
    DataOrchestratorService dataOrchestratorService) : ITargetDbOrchestratorService
{
    // We'll keep track of failed functions to retry them later (Circular dependency handling)
    private readonly List<ProgrammabilityModel> _failedFunctions = new();

    public async Task<string> PrepareTargetDb()
    {
        // 1. Docker Lifecycle (Start Container)
        var (pgPort, pgPassword) = await DockerService.HandleDockerContainerLifecycle(config, sourceDbData);

        // 2. Generate Scripts
        Msg.Write(MessageType.Info, "Generating structural scripts...");

        var dbCreationScript = PostgresScriptCreationService.GenerateDatabaseScript(config);
        var schemaScripts = PostgresScriptCreationService.GenerateSchemaScripts(sourceDbData);
        var udtScripts = PostgresScriptCreationService.GenerateUserDefinedDataTypeScripts(sourceDbData);
        var tableScripts = PostgresScriptCreationService.GenerateTableScripts(sourceDbData);
        var indexScripts = PostgresScriptCreationService.GenerateIndexScripts(sourceDbData); // Non-PK indexes
        var fkScripts = PostgresScriptCreationService.GenerateForeignKeyScripts(sourceDbData);
        var extensionScripts = PostgresScriptCreationService.GenerateExtensionScripts(sourceDbData);

        // Connection Strings
        // Maintenance: Connects to 'postgres' DB to create the target DB
        var maintenanceConnString = GeneratePostgresConnectionString(config, pgPort, pgPassword, "postgres");
        // Target: Connects to the new target DB
        var targetDbName = DatabaseHelper.GetDatabaseName(config.SourceConnectionString, DatabaseType.PostgreSQL);
        var targetDbConnectionString = GeneratePostgresConnectionString(config, pgPort, pgPassword, targetDbName);

        // --- EXECUTE IN STRICT DEPENDENCY ORDER ---
        Msg.Write(MessageType.Info, "Creating target database structure...");

        // 1. Base Database
        await CreateTargetDatabaseCore(dbCreationScript, maintenanceConnString, targetDbName);
        
        // 1.a Extensions
        await ExecuteScripts(extensionScripts, targetDbConnectionString, "Extensions");

        // 2. Schemas (Must be first)
        await ExecuteScripts(schemaScripts, targetDbConnectionString, "Schemas");

        // 3. User Defined Types (UDTs)
        await ExecuteScripts(udtScripts, targetDbConnectionString, "User Defined Types");

        // 4. FUNCTIONS PASS 1 (The "Pure Function" Pass)
        // Attempt to create all functions. Pure logic functions will succeed.
        await CreateTargetDatabaseFunctions(sourceDbData.Functions, targetDbConnectionString, isRetryPass: false);

        // 5. Tables
        // Now that "Pure" functions exist, tables with computed columns using them should work.
        // Note: PKs are usually inline in Postgres CREATE TABLE scripts generated by your service.
        await ExecuteScripts(tableScripts, targetDbConnectionString, "Tables");

        // 6. FUNCTIONS PASS 2 (The "Data-Access" Pass)
        // Retry functions that failed because tables didn't exist yet.
        if (_failedFunctions.Any())
        {
            await CreateTargetDatabaseFunctions(_failedFunctions, targetDbConnectionString, isRetryPass: true);
        }

        // 7. Indexes (Non-PK)
        await ExecuteScripts(indexScripts, targetDbConnectionString, "Indexes");

        // 8. Constraints & Relationships (FKs)
        await ExecuteScripts(fkScripts, targetDbConnectionString, "Foreign Keys");

        Msg.Write(MessageType.Success, "Base structure created successfully.");
        Console.WriteLine("");

        return targetDbConnectionString;
    }

    public async Task CreateDatabaseProgrammability(string targetDbConnectionString)
    {
        Msg.Write(MessageType.Info, "Applying database programmability (SPs, Views)...");

        // 1. Views
        var viewScripts = PostgresScriptCreationService.GenerateViewScripts(sourceDbData);
        await ExecuteScripts(viewScripts, targetDbConnectionString, "Views");

        // 2. Stored Procedures
        var procScripts = PostgresScriptCreationService.GenerateStoredProcedureScripts(sourceDbData);
        await ExecuteScripts(procScripts, targetDbConnectionString, "Stored Procedures");

        Msg.Write(MessageType.Success, "Programmability objects created successfully.");
        Console.WriteLine("");
    }
    

    private async Task CreateTargetDatabaseCore(string dbCreationScript, string maintenanceConnString, string targetDbName)
    {
        Msg.Write(MessageType.Info, "Creating target database...");

        try
        {
            using var conn = new NpgsqlConnection(maintenanceConnString);
            await conn.OpenAsync();

            // Check if exists and drop if necessary (though Docker container is usually fresh)
            var exists = await conn.ExecuteScalarAsync<int>($"SELECT 1 FROM pg_database WHERE datname = '{targetDbName}'");
            if (exists == 1)
            {
                Msg.Write(MessageType.Warning, $"Database '{targetDbName}' exists. Dropping...");
                await conn.ExecuteAsync($@"
                SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = '{targetDbName}' AND pid <> pg_backend_pid();
                DROP DATABASE ""{targetDbName}"";");
            }

            await conn.ExecuteAsync(dbCreationScript);
            Msg.Write(MessageType.Success, "Target database created successfully.");
            Console.WriteLine("");
        }
        catch (Exception ex)
        {
            Msg.Write(MessageType.Error, $"Unexpected error during target database creation: {ex.Message}");
            throw;
        }

        
    }

    private async Task ExecuteScripts(List<string> scripts, string connectionString, string objectType)
    {
        if (!scripts.Any()) return;

        Msg.Write(MessageType.Info, $"Creating {objectType}...");
        
        using var conn = new NpgsqlConnection(connectionString);
        await conn.OpenAsync();

        var hasWarnings = false;

        foreach (var sql in scripts)
        {
            try
            {
                await conn.ExecuteAsync(sql);
            }
            catch (PostgresException ex)
            {
                Msg.Write(MessageType.Warning, $"Failed to create {objectType} item. Error: {ex.MessageText}");
                hasWarnings = true;
            }
        }

        if (hasWarnings)
            Msg.Write(MessageType.Warning, $"Finished creating {objectType} with some warnings.");
        else
            Msg.Write(MessageType.Success, $"{objectType} created successfully.");
        
        Console.WriteLine("");
    }

    private async Task CreateTargetDatabaseFunctions(List<ProgrammabilityModel> functions, string connectionString, bool isRetryPass)
    {
        if (isRetryPass) Msg.Write(MessageType.Info, $"Retrying {functions.Count} functions that depend on tables...");
        else Msg.Write(MessageType.Info, "Creating target database functions (Pass 1)...");

        using var conn = new NpgsqlConnection(connectionString);
        await conn.OpenAsync();

        foreach (var func in functions)
        {
            try
            {
                // Postgres functions might be CREATE OR REPLACE, ensuring idempotency
                await conn.ExecuteAsync(func.Definition);
            }
            catch (PostgresException)
            {
                if (!isRetryPass)
                {
                    // Pass 1 Failure: Defer it
                    _failedFunctions.Add(func);
                    Msg.Write(MessageType.Debug, $"Deferred function {func.SchemaName}.{func.ObjectName} (likely depends on tables).");
                }
                else
                {
                    // Pass 2 Failure: Real error
                    Msg.Write(MessageType.Warning, $"Could not create function {func.SchemaName}.{func.ObjectName} even after table creation.");
                }
            }
        }

        if (isRetryPass && _failedFunctions.Any())
        {
            Msg.Write(MessageType.Success, "Function creation retry pass complete.");
        }
        Console.WriteLine("");
    }

    private static string GeneratePostgresConnectionString(KopiConfig config, int port, string password, string database)
    {
        var builder = new NpgsqlConnectionStringBuilder
        {
            Host = "localhost",
            Port = port,
            Username = "postgres",
            Password = password,
            Database = database,
            IncludeErrorDetail = true
        };
        return builder.ConnectionString;
    }
}